
<!doctype html>

<html lang="en">
<head>
  <link rel="icon" href="favicon.png" type="image/png">
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Offline Keypair Generator — Dark</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    html,body{height:100%}
    body{background:#0b0f14;color:#e6eef8;max-width:900px;margin:14px auto;padding:18px;line-height:1.5}
    h1{font-size:1.25rem;margin:0 0 6px;color:#fff}
    p.small{color:#9aa6b2;margin:6px 0 16px;font-size:0.95rem}
    .card{border:1px solid rgba(255,255,255,0.06);border-radius:10px;padding:14px;margin:12px 0;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01))}
    label{display:block;font-weight:600;margin-bottom:6px;color:#cfe3ff}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button, select{padding:8px 10px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:rgba(255,255,255,0.02);color:#e6eef8}
    button:active{transform:translateY(1px)}
    pre{white-space:pre-wrap;word-break:break-word;background:#071018;color:#d7eef8;padding:12px;border-radius:8px;overflow:auto;border:1px solid rgba(255,255,255,0.03)}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    .meta{font-size:0.9rem;color:#9aa6b2;margin:6px 0}
    .inline{display:inline-flex;gap:6px;align-items:center}
    .smallbutton{padding:6px 8px;font-size:0.85rem}
    textarea{background:#071018;color:#e6eef8;border:1px solid rgba(255,255,255,0.03);border-radius:8px}
    footer{font-size:0.82rem;color:#7f8b95;margin-top:18px}
    .danger{color:#ff9b9b}
    @media (max-width:420px){body{padding:12px}}
  </style>
</head>
<body>
  <h1>Offline Keypair Generator (Dark)</h1>
  <p class="small">Generates a public/private RSA keypair **entirely in your browser**. The page clears any stored data on load so nothing from previous sessions remains. Save this file and open locally or host on GH Pages over HTTPS.</p>

  <div class="card">
    <label for="alg">Algorithm & strength</label>
    <div class="controls">
      <select id="alg">
        <option value="rsa-2048">RSA-OAEP (2048)</option>
        <option value="rsa-4096">RSA-OAEP (4096)</option>
      </select>
      <button id="generate" class="smallbutton">Generate Keypair</button>
      <button id="downloadAll" class="smallbutton">Download PEM files</button>
      <button id="clear" class="smallbutton">Clear</button>
    </div>
    <div class="meta">Tip: 2048 is fast and compatible; 4096 is stronger but slower on phones.</div>
  </div>

  <div class="card">
    <label>Public Key (PEM) — shareable</label>
    <div class="row">
      <button id="copyPublic" class="smallbutton">Copy</button>
      <button id="downloadPublic" class="smallbutton">Download</button>
    </div>
    <pre id="publicPem">(no key yet)</pre>
  </div>

  <div class="card">
    <label>Private Key (PEM) — keep secret</label>
    <div class="row">
      <button id="copyPrivate" class="smallbutton">Copy</button>
      <button id="downloadPrivate" class="smallbutton">Download</button>
    </div>
    <pre id="privatePem">(no key yet)</pre>
  </div>

  <div class="card">
    <label>Quick test — encrypt with public, decrypt with private</label>
    <div class="meta">Type a short message and click <b>Encrypt & Decrypt</b>.</div>
    <textarea id="testMsg" rows="3" style="width:100%;padding:8px;border-radius:8px;margin:8px 0">Hello!</textarea>
    <div class="row">
      <button id="testBtn" class="smallbutton">Encrypt & Decrypt</button>
      <button id="copyCipher" class="smallbutton">Copy Ciphertext</button>
    </div>
    <label>Ciphertext (base64)</label>
    <pre id="cipher">(no ciphertext)</pre>
    <label>Decrypted result</label>
    <pre id="plain">(no result)</pre>
  </div>

  <footer>Offline. No telemetry. The page tries to delete localStorage, sessionStorage, caches and IndexedDB entries on load so nothing persists between sessions.</footer>

  <script>
  // --- Secure wipe on load ---
  async function wipeAllStoredData(){
    try{
      // local/session storage
      try{ localStorage.clear(); } catch(e){}
      try{ sessionStorage.clear(); } catch(e){}

      // caches (Service Worker / Cache API)
      if(window.caches && caches.keys){
        const keys = await caches.keys();
        await Promise.all(keys.map(k => caches.delete(k)));
      }

      // IndexedDB: use indexedDB.databases() if available, otherwise attempt common names
      if(indexedDB && indexedDB.databases){
        const dbs = await indexedDB.databases();
        await Promise.all(dbs.map(db => indexedDB.deleteDatabase(db.name)));
      } else if(indexedDB){
        // best-effort: try deleting a few likely names
        const likely = ['key-store','keys','crypto-store','database'];
        for(const n of likely) try{ indexedDB.deleteDatabase(n); }catch(e){}
      }

      // unregister service workers (if any)
      if('serviceWorker' in navigator){
        const regs = await navigator.serviceWorker.getRegistrations();
        for(const r of regs) try{ await r.unregister(); } catch(e){}
      }

      // small pause to let deletions settle
      await new Promise(r => setTimeout(r, 100));
    }catch(e){
      // non-fatal
      console.warn('wipeAllStoredData error', e);
    }
  }

  // run wipe immediately on page load
  (async ()=>{ await wipeAllStoredData(); })();

  // --- helpers ---
  function bufToBase64(buf){
    // chunked conversion for large buffers
    const bytes = new Uint8Array(buf);
    const chunkSize = 0x8000; // 32KB
    let binary = '';
    for (let i = 0; i < bytes.length; i += chunkSize) {
      binary += String.fromCharCode.apply(null, bytes.subarray(i, i + chunkSize));
    }
    return btoa(binary);
  }
  function base64ToBuf(b64){
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
    return arr.buffer;
  }

  function wrapPem(base64, label){
    if(!base64) return `-----BEGIN ${label}-----
-----END ${label}-----`;
    const lines = (base64.match(/.{1,64}/g) || []).join('
');
    return `-----BEGIN ${label}-----
${lines}
-----END ${label}-----`;
  }

  // Elements
  const generateBtn = document.getElementById('generate');
  const algSelect = document.getElementById('alg');
  const publicPemEl = document.getElementById('publicPem');
  const privatePemEl = document.getElementById('privatePem');
  const copyPublic = document.getElementById('copyPublic');
  const copyPrivate = document.getElementById('copyPrivate');
  const downloadPublic = document.getElementById('downloadPublic');
  const downloadPrivate = document.getElementById('downloadPrivate');
  const downloadAll = document.getElementById('downloadAll');
  const clearBtn = document.getElementById('clear');
  const testBtn = document.getElementById('testBtn');
  const testMsg = document.getElementById('testMsg');
  const cipherEl = document.getElementById('cipher');
  const plainEl = document.getElementById('plain');
  const copyCipher = document.getElementById('copyCipher');

  // state
  let lastKeyPair = null; // CryptoKey pair
  let lastPublicPem = '';
  let lastPrivatePem = '';
  let lastCipherB64 = '';

  async function generateKeypair(){
    const alg = algSelect.value;
    let modulusLength = alg === 'rsa-4096' ? 4096 : 2048;
    // generate RSA-OAEP
    const kp = await crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: modulusLength,
        publicExponent: new Uint8Array([1,0,1]),
        hash: 'SHA-256'
      },
      true, // exportable
      ['encrypt','decrypt']
    );

    // export public (spki) and private (pkcs8)
    const pubDer = await crypto.subtle.exportKey('spki', kp.publicKey);
    const privDer = await crypto.subtle.exportKey('pkcs8', kp.privateKey);

    const pubB64 = bufToBase64(pubDer);
    const privB64 = bufToBase64(privDer);

    const pubPem = wrapPem(pubB64, 'PUBLIC KEY');
    const privPem = wrapPem(privB64, 'PRIVATE KEY');

    lastKeyPair = kp;
    lastPublicPem = pubPem;
    lastPrivatePem = privPem;

    publicPemEl.textContent = pubPem;
    privatePemEl.textContent = privPem;
    cipherEl.textContent = '(no ciphertext)';
    plainEl.textContent = '(no result)';

    return kp;
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      alert('Copied to clipboard');
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text; document.body.appendChild(ta); ta.select();
      try{ document.execCommand('copy'); alert('Copied to clipboard'); }catch(e){ alert('Copy failed'); }
      ta.remove();
    }
  }

  function downloadFile(filename, text){
    const a = document.createElement('a');
    const blob = new Blob([text], {type:'application/octet-stream'});
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href),2000);
  }

  // buttons
  generateBtn.addEventListener('click', async ()=>{
    generateBtn.disabled = true;
    generateBtn.textContent = 'Generating...';
    try{
      await generateKeypair();
    }catch(e){
      alert('Error: '+e.message);
    }finally{
      generateBtn.disabled = false;
      generateBtn.textContent = 'Generate Keypair';
    }
  });

  copyPublic.addEventListener('click', ()=>{
    if(!lastPublicPem) return alert('No public key yet');
    copyToClipboard(lastPublicPem);
  });
  copyPrivate.addEventListener('click', ()=>{
    if(!lastPrivatePem) return alert('No private key yet');
    copyToClipboard(lastPrivatePem);
  });

  downloadPublic.addEventListener('click', ()=>{
    if(!lastPublicPem) return alert('No public key yet');
    downloadFile('public.pem', lastPublicPem);
  });
  downloadPrivate.addEventListener('click', ()=>{
    if(!lastPrivatePem) return alert('No private key yet');
    downloadFile('private.pem', lastPrivatePem);
  });

  downloadAll.addEventListener('click', ()=>{
    if(!lastPublicPem && !lastPrivatePem) return alert('No keys yet');
    if(lastPublicPem) downloadFile('public.pem', lastPublicPem);
    if(lastPrivatePem) downloadFile('private.pem', lastPrivatePem);
  });

  clearBtn.addEventListener('click', ()=>{
    lastKeyPair = null; lastPublicPem=''; lastPrivatePem=''; lastCipherB64='';
    publicPemEl.textContent='(no key yet)'; privatePemEl.textContent='(no key yet)'; cipherEl.textContent='(no ciphertext)'; plainEl.textContent='(no result)';
  });

  // test encrypt & decrypt
  testBtn.addEventListener('click', async ()=>{
    if(!lastKeyPair) return alert('Generate keys first');
    const text = testMsg.value || '';
    const enc = new TextEncoder();
    const data = enc.encode(text);
    try{
      const cipherBuf = await crypto.subtle.encrypt({name:'RSA-OAEP'}, lastKeyPair.publicKey, data);
      const cipherB64 = bufToBase64(cipherBuf);
      lastCipherB64 = cipherB64;
      cipherEl.textContent = cipherB64;
      // decrypt
      const decBuf = await crypto.subtle.decrypt({name:'RSA-OAEP'}, lastKeyPair.privateKey, cipherBuf);
      const dec = new TextDecoder().decode(decBuf);
      plainEl.textContent = dec;
    }catch(e){
      alert('Encrypt/Decrypt failed: '+e.message);
    }
  });

  copyCipher.addEventListener('click', ()=>{
    if(!lastCipherB64) return alert('No ciphertext');
    copyToClipboard(lastCipherB64);
  });

  // prevent accidental caching/restore by the browser's bfcache
  window.addEventListener('pageshow', (ev)=>{
    if(ev.persisted){
      // if page was restored from bfcache, do a hard reload to ensure fresh state
      try{ window.location.reload(); }catch(e){}
    }
  });

  // final safety: revoke any created object URLs when page unloads
  window.addEventListener('unload', ()=>{
    // nothing to revoke centrally; object URLs are revoked after downloads
  });
  </script>
</body>
</html>
