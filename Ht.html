<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Instant Keypair Generator (offline)</title>
  <style>
    :root{font-family:system-ui,-apple-system,Segoe UI,Roboto,'Helvetica Neue',Arial}
    body{max-width:900px;margin:18px auto;padding:18px;line-height:1.45}
    h1{font-size:1.25rem;margin:0 0 8px}
    p.small{color:#444;margin:6px 0 18px;font-size:0.95rem}
    .card{border:1px solid #e2e8f0;border-radius:10px;padding:12px;margin:12px 0;background:#fff}
    label{display:block;font-weight:600;margin-bottom:6px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    button, select{padding:8px 10px;border-radius:8px;border:1px solid #cbd5e1;background:#f8fafc}
    pre{white-space:pre-wrap;word-break:break-word;background:#0f172a;color:#e6eef8;padding:12px;border-radius:8px;overflow:auto}
    .controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:12px}
    .meta{font-size:0.9rem;color:#333;margin:6px 0}
    .inline{display:inline-flex;gap:6px;align-items:center}
    .smallbutton{padding:6px 8px;font-size:0.85rem}
    footer{font-size:0.85rem;color:#666;margin-top:18px}
    @media (max-width:420px){body{padding:12px}}
  </style>
</head>
<body>
  <h1>Offline Keypair Generator (RSA-OAEP)</h1>
  <p class="small">This page generates a public/private key pair inside your browser. It never leaves your device unless you copy or download it. Works fully offline — save the file and open it on your phone.</p>  <div class="card">
    <label for="alg">Algorithm & strength</label>
    <div class="controls">
      <select id="alg">
        <option value="rsa-2048">RSA-OAEP (2048)</option>
        <option value="rsa-4096">RSA-OAEP (4096)</option>
      </select>
      <button id="generate" class="smallbutton">Generate Keypair</button>
      <button id="downloadAll" class="smallbutton">Download PEM files</button>
      <button id="clear" class="smallbutton">Clear</button>
    </div>
    <div class="meta">Tip: Use RSA for compatibility. If you need smaller/faster keys in production use modern curves (not shown here).</div>
  </div>  <div class="card">
    <label>Public Key (PEM) — shareable</label>
    <div class="row">
      <button id="copyPublic" class="smallbutton">Copy</button>
      <button id="downloadPublic" class="smallbutton">Download</button>
    </div>
    <pre id="publicPem">(no key yet)</pre>
  </div>  <div class="card">
    <label>Private Key (PEM) — keep secret</label>
    <div class="row">
      <button id="copyPrivate" class="smallbutton">Copy</button>
      <button id="downloadPrivate" class="smallbutton">Download</button>
    </div>
    <pre id="privatePem">(no key yet)</pre>
  </div>  <div class="card">
    <label>Quick test — encrypt with public, decrypt with private</label>
    <div class="meta">Type a short message and click <b>Encrypt & Decrypt</b>.</div>
    <textarea id="testMsg" rows="3" style="width:100%;padding:8px;border-radius:8px;border:1px solid #cbd5e1;margin:8px 0">Hello!</textarea>
    <div class="row">
      <button id="testBtn" class="smallbutton">Encrypt & Decrypt</button>
      <button id="copyCipher" class="smallbutton">Copy Ciphertext</button>
    </div>
    <label>Ciphertext (base64)</label>
    <pre id="cipher">(no ciphertext)</pre>
    <label>Decrypted result</label>
    <pre id="plain">(no result)</pre>
  </div>  <footer>Completely offline. No telemetry. If you want a downloadable single-file HTML, save this page on your device and open it in the browser.</footer>  <script>
  // Utility helpers
  function bufToBase64(buf){
    return btoa(String.fromCharCode.apply(null, new Uint8Array(buf)));
  }
  function base64ToBuf(b64){
    const bin = atob(b64);
    const arr = new Uint8Array(bin.length);
    for(let i=0;i<bin.length;i++) arr[i]=bin.charCodeAt(i);
    return arr.buffer;
  }

  function wrapPem(base64, label){
    const lines = base64.match(/.{1,64}/g).join('\n');
    return `-----BEGIN ${label}-----\n${lines}\n-----END ${label}-----`;
  }

  // Elements
  const generateBtn = document.getElementById('generate');
  const algSelect = document.getElementById('alg');
  const publicPemEl = document.getElementById('publicPem');
  const privatePemEl = document.getElementById('privatePem');
  const copyPublic = document.getElementById('copyPublic');
  const copyPrivate = document.getElementById('copyPrivate');
  const downloadPublic = document.getElementById('downloadPublic');
  const downloadPrivate = document.getElementById('downloadPrivate');
  const downloadAll = document.getElementById('downloadAll');
  const clearBtn = document.getElementById('clear');
  const testBtn = document.getElementById('testBtn');
  const testMsg = document.getElementById('testMsg');
  const cipherEl = document.getElementById('cipher');
  const plainEl = document.getElementById('plain');
  const copyCipher = document.getElementById('copyCipher');

  // state
  let lastKeyPair = null; // CryptoKey pair
  let lastPublicPem = '';
  let lastPrivatePem = '';
  let lastCipherB64 = '';

  async function generateKeypair(){
    const alg = algSelect.value;
    let modulusLength = alg === 'rsa-4096' ? 4096 : 2048;
    // generate RSA-OAEP
    const kp = await crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: modulusLength,
        publicExponent: new Uint8Array([1,0,1]),
        hash: 'SHA-256'
      },
      true, // exportable
      ['encrypt','decrypt']
    );

    // export public (spki) and private (pkcs8)
    const pubDer = await crypto.subtle.exportKey('spki', kp.publicKey);
    const privDer = await crypto.subtle.exportKey('pkcs8', kp.privateKey);

    const pubB64 = bufToBase64(pubDer);
    const privB64 = bufToBase64(privDer);

    const pubPem = wrapPem(pubB64, 'PUBLIC KEY');
    const privPem = wrapPem(privB64, 'PRIVATE KEY');

    lastKeyPair = kp;
    lastPublicPem = pubPem;
    lastPrivatePem = privPem;

    publicPemEl.textContent = pubPem;
    privatePemEl.textContent = privPem;
    cipherEl.textContent = '(no ciphertext)';
    plainEl.textContent = '(no result)';

    return kp;
  }

  async function copyToClipboard(text){
    try{
      await navigator.clipboard.writeText(text);
      alert('Copied to clipboard');
    }catch(e){
      // fallback
      const ta = document.createElement('textarea');
      ta.value = text; document.body.appendChild(ta); ta.select();
      try{ document.execCommand('copy'); alert('Copied to clipboard'); }catch(e){ alert('Copy failed'); }
      ta.remove();
    }
  }

  function downloadFile(filename, text){
    const a = document.createElement('a');
    const blob = new Blob([text], {type:'application/octet-stream'});
    a.href = URL.createObjectURL(blob);
    a.download = filename;
    a.click();
    setTimeout(()=>URL.revokeObjectURL(a.href),2000);
  }

  // buttons
  generateBtn.addEventListener('click', async ()=>{
    generateBtn.disabled = true;
    generateBtn.textContent = 'Generating...';
    try{
      await generateKeypair();
    }catch(e){
      alert('Error: '+e.message);
    }finally{
      generateBtn.disabled = false;
      generateBtn.textContent = 'Generate Keypair';
    }
  });

  copyPublic.addEventListener('click', ()=>{
    if(!lastPublicPem) return alert('No public key yet');
    copyToClipboard(lastPublicPem);
  });
  copyPrivate.addEventListener('click', ()=>{
    if(!lastPrivatePem) return alert('No private key yet');
    copyToClipboard(lastPrivatePem);
  });

  downloadPublic.addEventListener('click', ()=>{
    if(!lastPublicPem) return alert('No public key yet');
    downloadFile('public.pem', lastPublicPem);
  });
  downloadPrivate.addEventListener('click', ()=>{
    if(!lastPrivatePem) return alert('No private key yet');
    downloadFile('private.pem', lastPrivatePem);
  });

  downloadAll.addEventListener('click', ()=>{
    if(!lastPublicPem && !lastPrivatePem) return alert('No keys yet');
    if(lastPublicPem) downloadFile('public.pem', lastPublicPem);
    if(lastPrivatePem) downloadFile('private.pem', lastPrivatePem);
  });

  clearBtn.addEventListener('click', ()=>{
    lastKeyPair = null; lastPublicPem=''; lastPrivatePem=''; lastCipherB64='';
    publicPemEl.textContent='(no key yet)'; privatePemEl.textContent='(no key yet)'; cipherEl.textContent='(no ciphertext)'; plainEl.textContent='(no result)';
  });

  // test encrypt & decrypt
  testBtn.addEventListener('click', async ()=>{
    if(!lastKeyPair) return alert('Generate keys first');
    const text = testMsg.value || '';
    const enc = new TextEncoder();
    const data = enc.encode(text);
    try{
      const cipherBuf = await crypto.subtle.encrypt({name:'RSA-OAEP'}, lastKeyPair.publicKey, data);
      const cipherB64 = bufToBase64(cipherBuf);
      lastCipherB64 = cipherB64;
      cipherEl.textContent = cipherB64;
      // decrypt
      const decBuf = await crypto.subtle.decrypt({name:'RSA-OAEP'}, lastKeyPair.privateKey, cipherBuf);
      const dec = new TextDecoder().decode(decBuf);
      plainEl.textContent = dec;
    }catch(e){
      alert('Encrypt/Decrypt failed: '+e.message);
    }
  });

  copyCipher.addEventListener('click', ()=>{
    if(!lastCipherB64) return alert('No ciphertext');
    copyToClipboard(lastCipherB64);
  });

  // disable long-running operations on mobile with a safety
  window.addEventListener('beforeunload', ()=>{});
  </script></body>
</html>
